Priorities
==========
- faster and sound flow analysis
- tail rec should be moved to a much earlier stage
- fix small bugs
  ==> integer arithmetic
- function representation/call (see runtime/runtime.js)

- using continuation with multiples arguments
  ==> graph coloring + variable coalescing
  ==> we should check stack compatibility when parsing:
      when jumping somewhere, the stack should keep the same shape
- more aggressive variable renaming? (in particular, for Control.block_simpl)
- remove "Variable x" instruction

- options on command line
  ==> compact mode
  ==> debugging options

- inlining
- constant hoisting (including functions, out of loops and functions)

===========

Special case for shortcut boolean operations...

     1
     |\
     | \2
     | /\
     |/  \
     3    4

==========================

BUGS
====
- compilation of raise
- compilation of functions in loops going through exception handlers
      let f () =
        let l = ref [] in
        for i = 1 to 100 do
          try l := (fun () -> i) :: !l; raise Exit with _ -> ()
        done;
        !l

- compile ISINT to "not a block" and document this deviation
  (or document that we should not rely on the Obj module)

- do arithmetic modulo for integers

- generate caml_call_N functions... (with short names when possible...)

- store meta-information in functions themselves, rather than using a
  block  ===> f.length

- define an alias for MlString function? (on the other hand, gzip
  should be quite effective...)

- fix definitions of max_int and min_int in pervasive...
  (not sure how...)

PERFORMANCE
===========
- should we rebind variables from a deeper level ?
  (only if used more than once...)

     var x = ...
     function () {
        var y = x;
        ... y .... y ... y ....
     }

COMPACT MODE
============
- We need to insert newlines from time to time to avoid problems with
  some routers...
- Code for variable renaming in Javascript code
  ==> also eliminate redundant "var"?
- Start with function parameters.  Then, variables that are used most.
- Use interference mechanism...

IMPROVEMENTS
============

- be more cautious regarding how we print floats...
  (is it accurate?)
  ==> gdtoa
    http://caml.inria.fr/pub/ml-archives/caml-list/2002/12/2813f8e8be115b0bad1bc16b1e41b744.en.html

- We only have to make sure we do not use a
  reserved word nor a function used outside for naming variables

- convert boolean to integer: (x)+0
  (is that faster than x?1:0 ?)

- explicit conversion from int to boolean

- simplify conditional definition
  should be:
     Cond of Var.t * cont * cont
  (we need to eliminate unnecessary conversions from bool to integer
   for that)

NEW FEATURES
============

- Map Caml objects to Javascript objects

- dynamic linking? (code generation from cmo files)

DATA REPRESENTATION
===================
- should wrap Ocaml exceptions (more robust code)...
- should perform array bound-checks

DATA ANALYSIS
=============
- correct analysis (side-effects...)
- faster algorithm
- interprocedural analysis

COMPRESSION OPTIMIZATION
========================
- http://timepedia.blogspot.com/2009/08/on-reducing-size-of-compressed.html
  http://timepedia.blogspot.com/2009/11/traveling-salesman-problem-and.html
  ==> order functions by similarity
  ==> try to always use the same arguments for functions
  ==> 7-zip is better at compressing than gzip, with the same algorithm...
- we can remove some whitespaces but we have to look at the context...

TYPES
=====

type 'a nullable

  null : 'a nullable
  the : 'a -> 'a nullable
  maybe : 'a nullable -> 'a option
  (flatten : 'a nullable nullable -> 'a nullable)

Use 32 bit signed integer (following the spec!)
===> bitwise operator are ok; the result of arithmeric operations must
     be truncated back to 32 bits
     (x|0 !)
===> we do not have enough bits for multiplication :-(
===> should probably also have 31 bit as an option, for compatibility...

DOCUMENTATION
=============
document as much as we can:
* the representation of datas, closures, ...
* the assumption we make regarding the bytecode
  ==> ISINT
  ==> special case for ASSIGN
  ==> loops and junctions ==> only the accu may changes (same stack)
      when two paths merge, not even that for loops

================================

REFERENCES
==========

http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/

http://code.google.com/closure/compiler/

http://code.google.com/p/ocamljs/source/browse/#svn/trunk/src

Inlining: see Manuel Serrano's paper

Resolving and Exploiting the k-CFA Paradox
Illuminating Functional vs. Object-Oriented Program Analysis
Matthew Might               Yannis Smaragdakis             David Van Horn

==================================

Use window.postMessage instead of setTimeout for yield (setTimeout
always waits a bit!)

