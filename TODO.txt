Priorities
==========
- how to parse "if (e) (if (e') st) else st'"???
- faster flow analysis
- fix compilation of closures within loops
- fix small bugs
- self tail recursion

- options on command line

===========

Conditionals compilation
========================

1. get parent branch continuation points

2. find continuation points of each branch
   if more than one overall, abort
   ===> map them all to a same node (for the sake of counting them)
        + set selection variable to implement jump to these nodes when
          compiling

3. recursively compile children (passing them existing continuation points)

4. if continuation point is not the same as the parent one compile the
   continuation point (step 2)
   ==> if several continuation points, add a switch to select between them

   otherwise, we are done

when compiling a switch, add a "break" at the tail of each branch with
a continuation point

"poptrap" are termination points when compiling a pushtrap node

if (e) {...; return} else {b} ===> if e {...; return}; b
      grey is empty for this block...

======

Loops: wrap closures inside functions.
Function arguments: any variable which occur inside the closure and is
   defined in the loop

   examples:
       x = !y; let f = fun () -> x in ...

       for i = ... to ... do let f = fun () -> i in ... done

=======

Special case for shortcut boolean operations...

     1
     |\
     | \2
     | /\
     |/  \
     3    4

==========================

BUGS
====

- "let x = !y in if e then incr y; (use x now)"
  ==> not sure how to fix this.  should we pass the whole stack at
      each block? (optimized away by coloring)? this make analysis
      more complex, but they will have to deal with self tail
      recursion anyway...

- compile ISINT to "not a block" and document this deviation
  (or document that we should not rely on the Obj module)

- do arithmetic modulo for integers

- bug with ASSIGN and closures in for loops: it is incorrect to modify
  the variable in place
  (not just assign, actually: any variable that may change)

- generate caml_call_N functions... (with short names when possible...)

- store meta-information in functions themselves, rather than using a
  block  ===> f.length ???

- define an alias for MlString function? (on the other hand, gzip
  should be quite effective...)

- fix definitions of max_int and min_int in pervasive...

COMPACT MODE
============
- We need to insert newlines from time to time to avoid problems with
  some routers...
- Code for variable renaming in Javascript code
  ==> also eliminate redundant "var"?
- Start with function parameters.  Then, variables that are used most.
- Use interference mechanism...

IMPROVEMENTS
============

- We only have to make sure we do not use a
  reserved word not a function used outside for naming variables
  ===> Bloom filter???

- convert boolean to integer: (x)+0
  (is that faster than x?1:0 ?)

- explicit conversion from int to boolean

- simplify conditional definition
  should be:
     Cond of Var.t * cont * cont
  (we need to eliminate unnecessary conversions from bool to integer
   for that)

NEW FEATURES
============

- Map Caml objects to Javascript objects

- dynamic linking? (code generation from cmo files)

DATA REPRESENTATION
===================
- should wrap Ocaml exceptions (more robust code)...
- should perform array bound-checks

DATA ANALYSIS
=============
- correct analysis (side-effects...)
- faster algorithm
- interprocedural analysis

COMPRESSION OPTIMIZATION
========================
- http://timepedia.blogspot.com/2009/08/on-reducing-size-of-compressed.html
  http://timepedia.blogspot.com/2009/11/traveling-salesman-problem-and.html
  ==> order functions by similarity
  ==> try to always use the same arguments for functions
  ==> 7-zip is better at compressing than gzip, with the same algorithm...
- we can remove some whitespaces but we have to look at the context...

TYPES
=====

type 'a nullable

  null : 'a nullable
  the : 'a -> 'a nullable
  maybe : 'a nullable -> 'a option
  (flatten : 'a nullable nullable -> 'a nullable)

Use 32 bit signed integer (following the spec!)
===> bitwise operator are ok; the result of arithmeric operations must
     be truncated back to 32 bits
     (x|0 !)
===> we do not have enough bits for multiplication :-(
===> should probably also have 31 bit as an option, for compatibility...

DOCUMENTATION
=============
document as much as we can:
* the representation of datas, closures, ...
* the assumption we make regarding the bytecode
  ==> ISINT
  ==> special case for ASSIGN
  ==> loops and junctions ==> only the accu may changes (same stack)
      when two paths merge, not even that for loops

================================

tail-call version of functions:

   function f(n, x1, ..., xn)
      { if (n >100) return new Trampoline(f, arguments); ...}

entry points:
  from non-tail call
  from tail position without trampoline
    - if function without tail calls, direct call
    - if function with tail calls, install trampoline and call
  from tail position with trampoline
    - if function without tail calls, call the function without 'n'
    - otherwise call function with counter


==========================

REFERENCES
==========

http://blog.higher-order.net/2009/09/08/understanding-clojures-persistenthashmap-deftwice/

http://code.google.com/closure/compiler/

http://code.google.com/p/ocamljs/source/browse/#svn/trunk/src

Inlining: see Manuel Serrano's paper

Resolving and Exploiting the k-CFA Paradox
Illuminating Functional vs. Object-Oriented Program Analysis
Matthew Might               Yannis Smaragdakis             David Van Horn
