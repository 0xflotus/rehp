/* Js_of_ocaml compiler
 * http://www.ocsigen.org/js_of_ocaml/
 * Copyright (C) 2010 Jérôme Vouillon
 * Laboratoire PPS - CNRS Université Paris Diderot
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, with linking exception;
 * either version 2.1 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

let debug = Option.Debug.find("main");
let times = Option.Debug.find("times");

module Primitive = Jsoo_primitive;
open Util;

let tailcall = p => {
  if (debug()) {
    Format.eprintf("Tail-call optimization...@.");
  };
  Tailcall.f(p);
};

let deadcode' = p => {
  if (debug()) {
    Format.eprintf("Dead-code...@.");
  };
  Jsoo_deadcode.f(p);
};

let deadcode = p => {
  let (r, _) = deadcode'(p);
  r;
};

let inline = p =>
  if (Option.Optim.inline() && Option.Optim.deadcode()) {
    let (p, live_vars) = deadcode'(p);
    if (debug()) {
      Format.eprintf("Inlining...@.");
    };
    Inline.f(p, live_vars);
  } else {
    p;
  };

let specialize_1 = ((p, info)) => {
  if (debug()) {
    Format.eprintf("Specialize...@.");
  };
  Specialize.f(info, p);
};

let specialize_js = ((p, info)) => {
  if (debug()) {
    Format.eprintf("Specialize js...@.");
  };
  Specialize_js.f(info, p);
};

let specialize' = ((p, info)) => {
  let p = specialize_1((p, info));
  let p = specialize_js((p, info));
  (p, info);
};

let specialize = p => fst(specialize'(p));

let eval = ((p, info)) =>
  if (Option.Optim.staticeval()) {
    Eval.f(info, p);
  } else {
    p;
  };

let flow = p => {
  if (debug()) {
    Format.eprintf("Data flow...@.");
  };
  Flow.f(p);
};

let flow_simple = p => {
  if (debug()) {
    Format.eprintf("Data flow...@.");
  };
  Flow.f(~skip_param=true, p);
};

let phi = p => {
  if (debug()) {
    Format.eprintf("Variable passing simplification...@.");
  };
  Phisimpl.f(p);
};

let print = p => {
  if (debug()) {
    Code.print_program((_, _) => "", p);
  };
  p;
};

let (>>) = (f, g, x) => g(f(x));

let rec loop = (max, name, round, i, p: 'a): 'a => {
  let p' = round(p);
  if (i >= max || Code.eq(p', p)) {
    p';
  } else {
    if (times()) {
      Format.eprintf("Start Iteration (%s) %d...@.", name, i);
    };
    loop(max, name, round, i + 1, p');
  };
};

let identity = x => x;

/* o1 */

let o1: 'a => 'a =
  /* print >> */
  tailcall
  >> flow_simple  /* flow simple to keep information for furture tailcall opt */
  >> specialize'
  >> eval
  >> inline  /* inlining may reveal new tailcall opt */
  >> deadcode
  >> tailcall
  >> phi
  >> flow
  >> specialize'
  >> eval
  >> inline
  >> deadcode
  /* print >> */
  >> flow
  >> specialize'
  >> eval
  >> inline
  >> deadcode
  >> phi
  >> flow
  >> specialize
  >> identity;

/* o2 */

let o2: 'a => 'a = loop(10, "o1", o1, 1) >> print;

/* o3 */

let round1: 'a => 'a =
  print
  >> tailcall
  >> inline  /* inlining may reveal new tailcall opt */
  >> deadcode
  /* deadcode required before flow simple -> provided by constant */
  >> flow_simple  /* flow simple to keep information for furture tailcall opt */
  >> specialize'
  >> eval
  >> identity;

let round2 = flow >> specialize' >> eval >> deadcode >> o1;

let o3 =
  loop(10, "tailcall+inline", round1, 1)
  >> loop(10, "flow", round2, 1)
  >> print;

let generate = (d, ~exported_runtime, (p, live_vars)) => {
  if (times()) {
    Format.eprintf("Start Generation...@.");
  };
  Generate.f(p, ~exported_runtime, live_vars, d);
};

let git_version = () =>
  switch (Compiler_version.git_version) {
  | "" => Compiler_version.s
  | v => Printf.sprintf("%s+git-%s", Compiler_version.s, v)
  };

let header = (formatter, ~custom_header) => {
  switch (custom_header) {
  | None => ()
  | Some(c) => Pretty_print.string(formatter, c ++ "\n")
  };
  let version = git_version();
  Pretty_print.string(
    formatter,
    "// Generated by js_of_ocaml " ++ version ++ "\n",
  );
};

let header_php = (formatter, ~custom_header) => {
  switch (custom_header) {
  | None => Pretty_print.string(formatter, "<?php" ++ "\n")
  | Some(c) => Pretty_print.string(formatter, c ++ "\n")
  };
  let version = git_version();
  Pretty_print.string(
    formatter,
    "# Generated by version " ++ version ++ "\n",
  );
};

let debug_linker = Option.Debug.find("linker");

let global_object = Option.global_object;

let extra_js_files =
  lazy (
    List.fold_left(
      (acc, file) =>
        try (
          {
            let ss =
              List.fold_left(
                (ss, (prov, _, _, _, _)) =>
                  switch (prov) {
                  | Some((_, name, _, _)) => StringSet.add(name, ss)
                  | _ => ss
                  },
                StringSet.empty,
                Linker.parse_file(file),
              );
            [(file, ss), ...acc];
          }
        ) {
        | _ => acc
        },
      [],
      Option.extra_js_files,
    )
  );

let report_missing_primitives = missing => {
  let missing =
    List.fold_left(
      (missing, (file, pro)) => {
        let d = StringSet.inter(missing, pro);
        if (! StringSet.is_empty(d)) {
          Util.warn("Missing primitives provided by %s:@.", file);
          StringSet.iter(nm => Util.warn("  %s@.", nm), d);
          StringSet.diff(missing, pro);
        } else {
          missing;
        };
      },
      missing,
      Lazy.force(extra_js_files),
    );
  if (! StringSet.is_empty(missing)) {
    Util.warn("Missing primitives:@.");
    StringSet.iter(nm => Util.warn("  %s@.", nm), missing);
  };
};

let gen_missing = (js, missing) => {
  open Rehp;
  let miss =
    StringSet.fold(
      (prim, acc) => {
        let p = S({name: prim, var: None});
        [
          (
            p,
            Some((
              ECond(
                EBin(
                  NotEqEq,
                  EDot(EVar(S({name: global_object, var: None})), prim),
                  EVar(S({name: "undefined", var: None})),
                ),
                EDot(EVar(S({name: global_object, var: None})), prim),
                EFun((
                  None,
                  [],
                  [
                    (
                      Statement(
                        Expression_statement(
                          ECall(
                            EVar(S({name: "caml_failwith", var: None})),
                            [
                              EBin(
                                Plus,
                                EStr(prim, `Utf8),
                                EStr(" not implemented", `Utf8),
                              ),
                            ],
                            N,
                          ),
                        ),
                      ),
                      N,
                    ),
                  ],
                  None,
                  N,
                )),
              ),
              N,
            )),
          ),
          ...acc,
        ];
      },
      missing,
      [],
    );
  if (! StringSet.is_empty(missing)) {
    Util.warn("There are some missing primitives@.");
    Util.warn("Dummy implementations (raising 'Failure' exception) ");
    Util.warn("will be used if they are not available at runtime.@.");
    Util.warn(
      "You can prevent the generation of dummy implementations with ",
    );
    Util.warn("the commandline option '--disable genprim'@.");
    report_missing_primitives(missing);
  };
  [(Statement(Variable_statement(miss)), N), ...js];
};

let link = (~standalone, ~linkall, ~export_runtime, js) =>
  if (! standalone) {
    js;
  } else {
    let t = Util.Timer.make();
    if (times()) {
      Format.eprintf("Start Linking...@.");
    };
    let traverse = new Rehp_traverse.free;
    let js = traverse#program(js);
    let free = traverse#get_free_name;

    let prim = Primitive.get_external();
    let prov = Linker.get_provided();

    let all_external = StringSet.union(prim, prov);

    let used = StringSet.inter(free, all_external);

    let linkinfos = Linker.init();
    let (linkinfos, missing) =
      Linker.resolve_deps(~linkall, linkinfos, used);

    /* gen_missing may use caml_failwith */
    let (linkinfos, missing) =
      if (! StringSet.is_empty(missing) && Option.Optim.genprim()) {
        let (linkinfos, missing2) =
          Linker.resolve_deps(
            linkinfos,
            StringSet.singleton("caml_failwith"),
          );
        (linkinfos, StringSet.union(missing, missing2));
      } else {
        (linkinfos, missing);
      };

    let js =
      if (Option.Optim.genprim()) {
        gen_missing(js, missing);
      } else {
        js;
      };
    if (times()) {
      Format.eprintf("  linking: %a@.", Util.Timer.print, t);
    };
    let js =
      if (export_runtime) {
        open Rehp;
        let all = Linker.all(linkinfos);
        let all =
          List.map(
            name => (Rehp_shared.PNI(name), EVar(S({name, var: None}))),
            all,
          );
        [
          (
            Statement(
              Expression_statement(
                EBin(
                  Eq,
                  EDot(
                    EVar(S({name: global_object, var: None})),
                    "jsoo_runtime",
                  ),
                  EObj(all),
                ),
              ),
            ),
            N,
          ),
          ...js,
        ];
      } else {
        js;
      };

    Linker.link(js, linkinfos);
  };

let check_js = js => {
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Checks...@.");
  };

  let traverse = new Rehp_traverse.free;
  let js = traverse#program(js);
  let free = traverse#get_free_name;

  let prim = Primitive.get_external();
  let prov = Linker.get_provided();

  let all_external = StringSet.union(prim, prov);

  let missing = StringSet.inter(free, all_external);
  let missing = StringSet.diff(missing, Reserved.provided);

  let other = StringSet.diff(free, missing);

  let res = VarPrinter.get_reserved();
  let other = StringSet.diff(other, res);
  if (! StringSet.is_empty(missing)) {
    report_missing_primitives(missing);
  };

  let probably_prov = StringSet.inter(other, Reserved.provided);
  let other = StringSet.diff(other, probably_prov);

  if (! StringSet.is_empty(other) && debug_linker()) {
    Util.warn("Missing variables:@.");
    StringSet.iter(nm => Util.warn("  %s@.", nm), other);
  };

  if (! StringSet.is_empty(probably_prov) && debug_linker()) {
    Util.warn("Variables provided by the browser:@.");
    StringSet.iter(nm => Util.warn("  %s@.", nm), probably_prov);
  };
  if (times()) {
    Format.eprintf("  checks: %a@.", Util.Timer.print, t);
  };
  js;
};

let coloring = js => {
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Coloring...@.");
  };
  let traverse = new Rehp_traverse.free;
  let js = traverse#program(js);
  let free = traverse#get_free_name;
  VarPrinter.add_reserved(StringSet.elements(free));
  let js = Js_assign.program(js);
  if (times()) {
    Format.eprintf("  coloring: %a@.", Util.Timer.print, t);
  };
  js;
};

let output_js =
    (formatter, ~standalone, ~custom_header, ~source_map=?, (), js) => {
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Writing file...@.");
  };
  if (standalone) {
    header(~custom_header, formatter);
  };
  Js_output.program(formatter, ~source_map?, js);
  if (times()) {
    Format.eprintf("  write: %a@.", Util.Timer.print, t);
  };
};

/* TODO:
 * Should also convert any top level EFuns that do not have any free vars
 * (except globals), to Function_declarations. Replacing identifiers throughout
 * with identifiers that don't use dollar signs.
 */

let output_php =
    (formatter, ~standalone, ~custom_header, ~source_map=?, (), js) => {
  /* Update the free variable book-keeping before printing. */
  let mapper = Rehp_mapper_free.mapper;
  let (_, js) = mapper.program(mapper, Rehp_mapper_free.empty, js);
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Writing file (Php)...@.");
  };
  if (standalone) {
    header_php(~custom_header, formatter);
  };
  Php_output.program(formatter, ~source_map?, js);
  if (times()) {
    Format.eprintf("  write: %a@.", Util.Timer.print, t);
  };
};

let pack = js => {
  module J = Rehp;
  /* pre pack optim */
  let js =
    if (Option.Optim.share_constant()) {
      let t1 = Util.Timer.make();
      let js = (new Rehp_traverse.share_constant)#program(js);
      if (times()) {
        Format.eprintf("    share constant: %a@.", Util.Timer.print, t1);
      };
      js;
    } else {
      js;
    };
  if (Option.Optim.compact_vardecl()) {
    let t2 = Util.Timer.make();
    let js = (new Rehp_traverse.compact_vardecl)#program(js);
    if (times()) {
      Format.eprintf("    compact var decl: %a@.", Util.Timer.print, t2);
    };
    js;
  } else {
    js;
  };
};

let post_pack_optimizations = js => {
  /* post pack optim */
  let t3 = Util.Timer.make();
  let js = (new Rehp_traverse.simpl)#program(js);
  if (times()) {
    Format.eprintf("    simpl: %a@.", Util.Timer.print, t3);
  };
  let t4 = Util.Timer.make();
  let js = (new Rehp_traverse.clean)#program(js);
  if (times()) {
    Format.eprintf("    clean: %a@.", Util.Timer.print, t4);
  };
  if (Option.Optim.shortvar()) {
    let t5 = Util.Timer.make();
    let keep = StringSet.empty;
    let js = (new Rehp_traverse.rename_variable)(keep)#program(js);
    if (times()) {
      Format.eprintf("    shortten vars: %a@.", Util.Timer.print, t5);
    };
    js;
  } else {
    js;
  };
};

let pack_js = (~global, js) => {
  module J = Rehp;
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Optimizing js...@.");
  };
  let js = pack(js);

  /* pack */
  let use_strict = js =>
    if (Option.Optim.strictmode()) {
      [
        (
          J.Statement(J.Expression_statement(J.EStr("use strict", `Utf8))),
          J.N,
        ),
        ...js,
      ];
    } else {
      js;
    };

  let js = {
    let f =
      J.EFun((
        None,
        [J.S({J.name: global_object, var: None})],
        use_strict(js),
        None,
        J.U,
      ));
    let expr =
      switch (global) {
      | `Function => f
      | `Bind_to(_) => f
      | `Custom(name) =>
        J.ECall(f, [J.EVar(J.S({J.name, var: None}))], J.N)
      | `Auto =>
        let global =
          J.ECall(
            J.EFun((
              None,
              [],
              [
                (
                  J.Statement(
                    J.Return_statement(
                      Some(J.EVar(J.S({J.name: "this", var: None}))),
                    ),
                  ),
                  J.N,
                ),
              ],
              None,
              J.N,
            )),
            [],
            J.N,
          );
        J.ECall(f, [global], J.N);
      };

    switch (global) {
    | `Bind_to(name) => [
        (
          J.Statement(
            J.Variable_statement([
              (J.S({J.name, var: None}), Some((expr, J.N))),
            ]),
          ),
          J.N,
        ),
      ]
    | _ => [(J.Statement(J.Expression_statement(expr)), J.N)]
    };
  };

  let js = post_pack_optimizations(js);
  if (times()) {
    Format.eprintf("  optimizing: %a@.", Util.Timer.print, t);
  };
  js;
};

let pack_php = (~global, js) => {
  module J = Rehp;
  let t = Util.Timer.make();
  if (times()) {
    Format.eprintf("Start Optimizing js...@.");
  };
  let js = pack(js);

  /* pack */
  let use_strict = js =>
    if (Option.Optim.strictmode()) {
      [
        (
          J.Statement(J.Expression_statement(J.EStr("use strict", `Utf8))),
          J.N,
        ),
        ...js,
      ];
    } else {
      js;
    };

  let js = {
    let f =
      J.EFun((
        None,
        [J.S({J.name: global_object, var: None})],
        use_strict(js),
        None,
        J.U,
      ));
    let expr =
      switch (global) {
      | `Function => f
      | `Bind_to(_) => f
      | `Custom(name) =>
        J.ECall(f, [J.EVar(J.S({J.name, var: None}))], J.N)
      | `Auto =>
        let global =
          J.ECall(
            J.EFun((
              None,
              [],
              [
                (
                  J.Statement(
                    J.Return_statement(
                      Some(J.EVar(J.S({J.name: "this", var: None}))),
                    ),
                  ),
                  J.N,
                ),
              ],
              None,
              J.N,
            )),
            [],
            J.N,
          );
        J.ECall(f, [global], J.N);
      };

    switch (global) {
    | `Bind_to(name) => [
        (
          J.Statement(
            J.Variable_statement([
              (J.S({J.name, var: None}), Some((expr, J.N))),
            ]),
          ),
          J.N,
        ),
      ]
    | _ => [(J.Statement(J.Expression_statement(expr)), J.N)]
    };
  };

  let js = post_pack_optimizations(js);
  if (times()) {
    Format.eprintf("  optimizing: %a@.", Util.Timer.print, t);
  };
  js;
};

let configure = (formatter, p) => {
  let pretty = Option.Optim.pretty();
  Pretty_print.set_compact(formatter, ! pretty);
  Code.Var.set_pretty(pretty && ! Option.Optim.shortvar());
  Code.Var.set_stable(Option.Optim.stable_var());
  p;
};

type profile = Code.program => Code.program;

let f =
    (
      ~standalone=true,
      ~global=`Auto,
      ~profile=o1,
      ~dynlink=false,
      ~backend=Backend.Js,
      ~linkall=false,
      ~source_map=?,
      ~custom_header=?,
      formatter,
      d,
    ) => {
  let exported_runtime = ! standalone;
  let linkall = linkall || dynlink;
  let outputter =
    switch (backend) {
    | Php => output_php
    | Js => output_js
    };
  let packer =
    switch (backend) {
    | Php => pack_php
    | Js => pack_js
    };
  configure(formatter)
  >> profile
  >> print
  >> Generate_closure.f
  >> print
  >> deadcode'
  >> generate(d, ~exported_runtime)
  >> link(~standalone, ~linkall, ~export_runtime=dynlink)
  >> packer(~global)
  >> coloring
  >> check_js
  >> outputter(formatter, ~standalone, ~custom_header, ~source_map?, ());
};

let from_string = (prims, s, formatter) => {
  let (p, d) = Parse_bytecode.from_string(prims, s);
  f(~standalone=false, ~global=`Function, formatter, d, p);
};

let profiles = [(1, o1), (2, o2), (3, o3)];
let profile = i =>
  try (Some(List.assoc(i, profiles))) {
  | Not_found => None
  };

let backends = [("js", Backend.Js), ("php", Backend.Php)];
